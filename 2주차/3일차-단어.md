문제를 봤을 때 아래 순서로 떠올리면 “전수 조사” 방식을 어렵지 않게 설계할 수 있습니다.

---

## 1️⃣ 입력·제약 조건 확인

* 사용할 알파벳 A, E, I, O, U → **5종류**
* 단어 길이 최대 **5자**
* 따라서 가능한 모든 단어 개수 =
  $5^1 + 5^2 + 5^3 + 5^4 + 5^5 = 3905$
* **3천여 개**면 파이썬으로 리스트에 담고 정렬·탐색해도 충분히 빠르다!

> 👉 “검색 공간이 작다 → 모든 경우를 다 만들어 봐도 괜찮다”라는 신호

---

## 2️⃣ 전수 조사 구조 구상

1. **모든 후보 생성**

    * 길이 1\~5를 반복하면서
    * 각 자리마다 5종 알파벳을 배치하는 조합 생성
2. **정렬**

    * 이 후보들을 사전 순($lex$)으로 정렬
3. **인덱스 조회**

    * 정렬된 리스트에서 `word`가 몇 번째인지 찾아서(0-based → +1) 반환

이 3단계만 머릿속에 있으면, “모음 사전” 문제는 반 이상 잡은 겁니다.

---

## 3️⃣ 코드 구현 포인트

```python
from itertools import product

def solution(word: str) -> int:
    vowels = ['A','E','I','O','U']
    candidates = []

    # 1) 후보 생성: 길이 1~5
    for length in range(1, 6):
        # product(vowels, repeat=length): 5^length 조합
        for tpl in product(vowels, repeat=length):
            candidates.append(''.join(tpl))

    # 2) 사전순 정렬
    candidates.sort()

    # 3) 위치 찾기 (+1 해 주기)
    return candidates.index(word) + 1
```

* **product**: 중첩된 for문 대신 간결하게 “모든 경우”를 만들어 주고
* **리스트.sort()**: 사전 순으로 한번에 정렬
* **.index() + 1**: 위치 조회

---

## 4️⃣ “막막함”을 넘는 팁

1. **검색 공간 크기 계산**

    * “알파벳 개수”×“최대 길이” 등을 곱·제곱해서 대략 크기 파악
    * 수천 단위 이하 → 브루트포스 OK, 수만\~백만 이상이면 다른 방법 고려

2. **핵심 로직 3단계로 쪼개기**

    1. **생성(generate)**
    2. **정렬(sort)**
    3. **탐색(find/index)**

3. **파이썬 내장 도구 활용**

    * `itertools.product` / `sort` / `index`는 전수 조사를 5줄 안팎으로 끝내 주는 마법 같은 도구

---

이렇게 “1) 제약으로 검색 공간 판단 → 2) 전수 조사 3단계 설계 → 3) itertools·정렬·탐색” 순서로 머릿속 플로우를 그려 보시면,
복잡해 보이는 문제도 부담 없이 “내가 쓸 수 있는 가장 단순한 방법”부터 시도해 볼 수 있을 거예요.
