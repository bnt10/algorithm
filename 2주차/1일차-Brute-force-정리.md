# 🗓 1일차: **Brute-force (브루트 포스) 기본 개념**

---

## 🔍 1. Brute-force (브루트 포스)란?

Brute-force란 "완전탐색"을 의미하는 알고리즘 접근 방법으로,
**모든 가능한 경우의 수를 하나하나 직접 다 확인**하는 방식입니다.

* **특징**

    * 직관적이며 단순한 방식
    * 구현하기 쉽고 코드가 단순함
    * 정확성을 보장하지만, 효율성은 떨어질 수 있음
    * 주어진 문제에서 최적의 해를 찾기 위해 무식하게 탐색함

---

## 🧠 2. Brute-force를 사용하는 이유

* 문제의 조건과 범위가 작아서 **모든 경우의 수를 다 확인해도 시간 안에 해결**될 때 적합
* 알고리즘 복잡성을 고민하지 않고도 정답을 얻고 싶을 때 편리
* 단순히 정답을 찾거나, 최적화 여부가 중요하지 않은 문제에서도 사용

---

## 📌 3. Brute-force의 절차

Brute-force는 보통 다음과 같은 순서로 진행됩니다.

| 단계                    | 설명                           |
| --------------------- | ---------------------------- |
| ① 문제 이해 및 접근법 선택      | 문제 조건을 분석하여 탐색 방법 결정         |
| ② 가능한 경우의 수 계산        | 전체 탐색이 가능한지 여부 판단 (범위 체크)    |
| ③ 반복문 또는 재귀로 모든 경우 탐색 | 중첩 반복문 또는 재귀함수를 통해 모든 경우를 나열 |
| ④ 해를 찾거나 비교           | 매 경우마다 문제 조건에 맞는지 확인하고 해를 갱신 |

---

## 📐 4. Brute-force 문제 접근 예시

### 예시 문제

> 길이가 최대 100인 배열에서 합이 정확히 100이 되는 두 수의 조합을 찾아라.

### Brute-force 접근법

* 배열의 원소가 최대 100개이고, 두 수를 뽑는 방법은 최대 100 × 99 / 2 = 4950가지로 많지 않음
  → **모든 가능한 쌍을 확인**하면 충분함.

### 코드 예시 (Python)

```python
def find_pair(arr, target):
    n = len(arr)
    for i in range(n):
        for j in range(i + 1, n):
            if arr[i] + arr[j] == target:
                return arr[i], arr[j]
    return None

print(find_pair([20, 30, 50, 70, 80], 100))  # (20, 80)
```

### 복잡도

* 시간복잡도: 보통 O(n²), 전체를 탐색하는 특성상 효율이 낮음
* 공간복잡도: 일반적으로 추가 공간이 거의 필요하지 않음 (O(1))

---

## 🎯 5. Brute-force 알고리즘의 대표 유형

| 유형          | 대표 예시 문제                                |
| ----------- | --------------------------------------- |
| 배열 탐색       | 모든 배열 요소를 조건에 맞춰 확인 (ex: 모의고사, 최소 직사각형) |
| 순열과 조합      | 가능한 모든 순서 혹은 선택의 조합을 확인                 |
| 문자열 탐색      | 부분 문자열을 모두 확인하여 일치 여부 판단                |
| 완전탐색 그래프 문제 | 그래프에서 모든 경로를 탐색하여 조건에 맞는 경우 찾기          |

---

## ⚠️ 6. Brute-force의 한계와 주의사항

* 입력 크기가 커지면 처리 시간이 급격히 증가
* 최적화된 방법이 존재하는 경우, 효율성을 위해 최적화를 시도해야 함

**적합하지 않은 경우**

* 데이터가 크거나 복잡도가 지나치게 높은 경우
* 문제에서 "효율성" 또는 "최적화"를 요구할 경우

---

## 🚀 7. Brute-force 학습을 위한 문제 추천

* **Lv.1 모의고사**
  → 배열 탐색을 이용한 모든 경우 비교 문제
* **Lv.1 최소직사각형**
  → 모든 케이스 탐색 후 min/max 함수로 간단히 처리할 수 있는 문제
* **Lv.2 카펫**
  → 수학적으로 모든 가능한 경우를 탐색하여 답을 찾는 문제

---

## 🎓 **정리**

| 구분         | Brute-force (완전탐색)                         |
| ---------- | ------------------------------------------ |
| **정의**     | 가능한 모든 경우를 확인하여 정답을 찾는 알고리즘                |
| **장점**     | 코드가 간단하고 직관적, 구현 용이                        |
| **단점**     | 입력 크기가 크면 효율이 낮음 (시간복잡도 O(n²), O(n³), ...) |
| **적합한 경우** | 입력 크기가 작고, 확실한 정답을 보장해야 할 때                |

---

이렇게 Brute-force 알고리즘의 기본 개념과 활용법을 정리했습니다.
다음 시간부터 실제 문제를 통해 Brute-force 알고리즘을 실습해보면 됩니다.
