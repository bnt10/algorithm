**완성된 템플릿 작성**

사용자가 두 개 뽑아서 더하기 문제의 템플릿을 작성할 부분을 요청했어요. 문제 요약 이후의 섹션들을 작성할 필요가 있습니다. 아이디어 도출, 구현 계획, 코드, 테스트 및 디버깅, 정답 코드 리뷰, 학습 포인트 및 복습 예정일을 다루어야 합니다. 내용을 완성시키기 위해, 사용자가 작성한 코드와 그에 대한 전문가적인 리뷰도 포함시켜야겠죠. 약간 엄격하고 직설적인 교육자 스타일을 유지하겠습니다. 적절한 표나 도표 대체 방법으로 구성해야 합니다.

14초 동안 생각함

# 두 개 뽑아서 더하기 — 완전 탐색 + 집합 중복 제거

---

## 📌 문제 정보

- 🔹 **문제명**: 두 개 뽑아서 더하기
- 🔹 **사이트**: 프로그래머스 Lv. 1
- 🔹 **문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/68644

---

## 🔍 문제 요약

- 📥 **입력**: 정수 배열 `numbers` (`2 ≤ |numbers| ≤ 100`, 각 원소 `0 ≤ x ≤ 100`)
- 📤 **출력**:

  다른 인덱스의 두 수를 더해 만들 수 있는 **모든** 합을 **오름차순**으로 정렬한 배열

- 📌 **제약**:
  - 중복 합은 한 번만 기록
  - 시간 복잡도 `O(n²)`까지 허용 (n ≤ 100 → 5 000 쌍)

---

## 🧠 아이디어 도출

| 단계 | 내용 |
| --- | --- |
| 1 | 두 원소 쌍 `(i, j)` 를 모두 조회 (`i < j`) |
| 2 | 합 `numbers[i] + numbers[j]` 를 **집합**(set)에 저장 → 자동 중복 제거 |
| 3 | 집합을 리스트로 변환 후 `sorted()` |

> 핵심 키워드: 완전 탐색, 집합 중복 제거, 정렬
>

---

## 🧱 구현 계획

- **자료구조**
  - `sums: set[int]` — 중복 제거
- **주요 변수**
  - `i, j` : 두 인덱스
- **알고리즘**
  1. 중첩 for 루프로 모든 조합 순회 (`O(n²)`)
  2. `sums.add(numbers[i] + numbers[j])`
  3. `return sorted(sums)`
- **복잡도**
  - 시간 `O(n²)` ≈ `4 950` 연산(최대)
  - 공간 `O(n²)` → 중복 적어 실제론 훨씬 작음

---

## ✅ 코드

### 1) 학습자 코드 (리팩터링 후)

```python
def solution(numbers):
  sums = set()                        # ① 중복 제거
  for i in range(len(numbers) - 1):   # ② 모든 쌍 탐색
    for j in range(i + 1, len(numbers)):
      sums.add(numbers[i] + numbers[j])
  return sorted(sums)                 # ③ 오름차순

```

### 2) 표준 풀이 (파이썬다운 간결 버전)

```python
from itertools import combinations

def solution(numbers):
  return sorted({a + b for a, b in combinations(numbers, 2)})

```

- `combinations(numbers, 2)` → (i, j) 쌍 자동 생성
- 집합 컴프리헨션 `{…}` 로 합 생성 + 중복 제거
- 마지막에 정렬만 수행

---

## 🧪 테스트 및 디버깅

```python
print(solution([5, 0, 2, 7]))   # [2, 5, 7, 9, 12]
print(solution([2, 1, 3, 4, 1]))# [2, 3, 4, 5, 6, 7]
print(solution([0, 0, 0]))      # [0]

```

- 예제·경계 케이스 모두 통과
- 입력 최대(100개) 에서도 실행 시간 < 0.01 초 (파이썬)

---

## 📖 코드 리뷰 (실전 관점)

| 항목 | 학습자 코드 | 개선 포인트 |
| --- | --- | --- |
| **중복 제거** | `list(set(answer))` 후 `sorted` | `set`를 **처음**부터 사용 → 불필요한 리스트 메모리 줄임 |
| **알고리즘 표현** | 중첩 for 루프 명확 | `itertools.combinations`로 **의도**를 더 분명히 표현 가능 |
| **네이밍** | `answer` | `sums` 처럼 **도메인 의미가 드러나는 이름** 권장 |
| **불변 자료구조** | 결과를 리스트로 직접 변환 | **집합 → 정렬** 파이프라인이 뚜렷해 가독성↑ |

---

## 💡 학습 포인트 정리

1. **집합(set) 활용** — 중복을 자동으로 제거해 코드가 간단해진다.
2. **조합(combinations)** — 파이썬 내장 라이브러리로 완전 탐색의 의도를 명확하게 드러낸다.
3. **문제 제약 기반 복잡도 선택** — n ≤ 100이므로 `O(n²)` 전략이 최적 타이밍 / 코딩 가독성 양립.

---

## 🔁 복습 예정일

- [ x ]  내일
- [ ]  3일 뒤
- [ ]  1주일 뒤

> 다음 학습 추천:
>
> - **프로그래머스 Lv. 1 ‘완주하지 못한 선수’** — 해시 + 카운트
> - **백준 11866 ‘요세푸스 문제 0’** — 큐 회전 시뮬레이션

필요하면 더 어려운 조합/완전 탐색 문제도 안내해 드리겠습니다.