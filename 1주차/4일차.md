**리스트 기본 메서드 작성**
# 배열(list) 기본

## 리스트 기본 내장 메서드

---

### `append()` – 리스트 끝에 원소 추가

| 항목         | 내용                             |
| ---------- |--------------------------------|
| **용도**     | 리스트 **맨 뒤**에 새 값을 추가           |
| **형식**     | `list.append(x)`               |
| **반환값**    | `None` (제자리 작업) - 해당 배열에 바로 적용 |
| **시간 복잡도** | **O(1)** *(가변 배열 특성)*          |
| **예시**     |                                |

```python
nums = [1, 2, 3]
nums.append(4)      # [1, 2, 3, 4]
```

---

### `pop()`– 원소 제거 & 반환
pop 의 시간 복잡도는 마지막 팝하면 1 나머지는 n

| 항목         | 내용                                                           |
| ---------- |--------------------------------------------------------------|
| **용도**     | 지정한 **인덱스**(기본: 마지막) 원소를 꺼내고 삭제                              |
| **형식**     | `list.pop([idx])`                                            |
| **반환값**    | 꺼낸 원소                                                        |
| **시간 복잡도** | **O(1)**(끝), **O(n)**(중간) -접근은 상수지만 shift 되는 과정에서 O(n-k) 복잡도 |
| **예시**     |                                                              |

```python
nums = [1, 2, 3, 4]
last = nums.pop()      # last=4, nums=[1, 2, 3]
mid  = nums.pop(1)     # mid=2,  nums=[1, 3]
```

> **Tip:** 스택 (push/pop)·큐(`pop(0)`) 구현 시 필수.

---

### `sort()` – 리스트 정렬

| 항목         | 내용                                 |
| ---------- |------------------------------------|
| **용도**     | **원본**을 오름차순(기본)으로 정렬              |
| **형식**     | `list.sort(key=None, reverse=False)` |
| **시간 복잡도** | **O(nlogn)**            |
| **예시**     |                                    |

```python
scores = [40, 10, 30, 20]
scores.sort()                     # [10, 20, 30, 40]
words = ["apple", "banana", "kiwi"]
words.sort(key=len, reverse=True) # ['banana', 'apple', 'kiwi']

```

> ✅ **`sorted()`**: 새 리스트 반환 (원본 보존).

---


### `reverse()`– 순서 뒤집기

| 항목         | 내용                       |
| ---------- |--------------------------|
| **용도**     | 리스트를 **역순**으로 배치  |
| **형식**     | `list.reverse()`         |
| **시간 복잡도** | **O(n)**                 |
| **예시**     |                          |

```python
nums = [1, 2, 3]
nums.reverse()   # [3, 2, 1]
```

> 🆚 **슬라이싱** `nums[::-1]`: 새 리스트 반환.

---

### 추가로 알아두면 좋은 메서드

| 메서드        | 설명                   | 예시                | 결과            |
| ---------- | -------------------- | ----------------- | ------------- |
| `extend()` | 다른 iterable 뒤에 다중 추가 | `a.extend([4,5])` | `[1,2,3,4,5]` |
| `insert()` | 지정 위치에 삽입            | `a.insert(1,"X")` | `[1,'X',2,3]` |
| `remove()` | 첫 번째 일치 원소 삭제        | `a.remove(2)`     | `[1,3]`       |
| `index()`  | 값 위치 반환              | `a.index(3)`      | `1`           |
| `count()`  | 값 개수 세기              | `a.count(1)`      | `2`           |
| `copy()`   | 얕은 복사                | `b = a.copy()`    | `b`는 새 리스트    |

---

## 연습문제

1. **스택 구현**
   * 빈 리스트 `stack`에 차례로 3,5,7을 `append()`로 넣고 **LIFO** 순서대로 `pop()` 해보세요.
2. **정렬 + 역순 출력**
   * 리스트 `[10, 2, 33, 8]`을 오름차순 `sort()` 후 `reverse()` 해서 **내림차순**으로 만들어 보세요.
3. **중앙 값 제거**
   * 리스트 `["a","b","c","d","e"]`에서 **중앙 원소**(인덱스2)를 `pop()`으로 제거하고 나머지를 출력하세요.

### 풀이 예시


```python
# 1
stack = []
for x in (3, 5, 7):
    stack.append(x)
print(stack.pop(), stack.pop(), stack.pop())  # 7 5 3

# 2
nums = [10, 2, 33, 8]
nums.sort()
nums.reverse()        # [33, 10, 8, 2]

# 3
letters = ["a", "b", "c", "d", "e"]
mid = len(letters)//2
removed = letters.pop(mid)
print(removed, letters)  # 'c' ['a', 'b', 'd', 'e']
```
